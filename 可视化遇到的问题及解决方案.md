# 可视化遇到的问题及解决方案：

好的，这是一份为你准备的、关于 `analysis.ipynb` 数据可视化（从头到尾）的“踩坑与爬坑”指南。

这份说明详细记录了我们遇到的每一个问题、诊断的根本原因，以及最终采用的正确解决方案，非常适合用来指导他人或作为你自己的总结复盘。

-----

### `analysis.ipynb` 数据可视化问题排查指南

在复现论文 的可视化过程中，我们遇到了一系列问题，主要集中在**文件路径**、**数据解析**和**字体显示**三个方面。本指南按时间顺序回顾了这些问题并提供了最终的解决方案。

#### 问题 1：`ValueError: need at least one array to concatenate`

  * **问题现象：**
    在尝试绘制 Figure 3a 时，Jupyter 报错 `ValueError: need at least one array to concatenate`。

  * **问题诊断：**

    1.  该错误发生在 `predictions = np.hstack(all_predictions)`。
    2.  `np.hstack` 报错是因为它收到的列表 `all_predictions` 是一个**空列表** `[]`。
    3.  `all_predictions` 为空，是因为 `glob.glob()` 函数没有找到任何匹配的文件。
    4.  `glob.glob()` 找不到文件，是因为我们最初查找了错误的文件名。我们本以为脚本 `1next-cycle-capacity.py` 会生成 `eis-actions...` 文件（对应论文中的核心 `EIS + Protocol`），但实际上该脚本的 `input_names` 列表里只包含了 `eis-cvfs-ct-c-actions` 等更复杂的特征组合。

  * **最终解决方案：**
    修改 `glob.glob()` 的查找模式，使其**精确匹配** `1next-cycle-capacity.py` 脚本**实际生成的** `.npy` 文件名。同时，规范化文件路径。

      * **对应的代码单元格（步骤 1.2 和 2.1）**：

    <!-- end list -->

    ```python
    # 步骤 1.2：加载并合并数据 (Fig 3a)
    
    # 路径：../ 返回到项目根，然后进入 'results'
    pred_path = '../results/variable-discharge/predictions/'
    
    # [关键修正] 查找脚本实际生成的文件
    glob_pattern_pred = 'pred_mn_eis-cvfs-ct-c-actions_n1_xgb_*.npy'
    glob_pattern_true = 'true_eis-cvfs-ct-c-actions_n1_xgb_*.npy'
    
    pred_files = sorted(glob.glob(os.path.join(pred_path, glob_pattern_pred)))
    true_files = sorted(glob.glob(os.path.join(pred_path, glob_pattern_true)))
    
    # ... (后续加载和 hstack 代码) ...
    
    # ----------------------------------------------------
    
    # 步骤 2.1：加载数据 (Fig 6b)
    
    # [关键修正] 规范化路径
    data_path = '../results/fixed-discharge/predictions/'
    
    # [关键修正] 确保 '1fixed-discharge-predict.py' 生成的是 'eis-actions'
    pred_robust = np.load(os.path.join(data_path, 'pred_mn_eis-actions.npy'))
    true_robust = np.load(os.path.join(data_path, 'true_eis-actions.npy'))
    
    # ... (后续代码) ...
    ```

-----

#### 问题 2：中文显示为方块（“豆腐块”）

  * **问题现象：**
    图表中的所有中文（标题、坐标轴标签）都显示为一个个的小方块。
  * **问题诊断：**
    这是 Matplotlib 的经典问题。它的默认字体（如 `Arial`）不包含中文字符，导致无法渲染。
  * **初步解决方案：**
    使用 `plt.rcParams` 指定一个本地的中文字体，例如 `SimHei` (黑体)。
    `plt.rcParams['font.sans-serif'] = ['SimHei']`

-----

#### 问题 3：中文仍然不显示，并出现 `Arial` 警告

  * **问题现象：**
    在执行了“初步解决方案”后，中文依然是方块，并且终端（或 Jupyter 输出）中充满了 `UserWarning: Glyph ... missing from font(s) Arial.` 的警告。

  * **问题诊断：**
    这证明我们设置的 `SimHei` 字体**没有生效**。
    根本原因是 `sns.set_theme(style="whitegrid")` 这行代码会**重置并覆盖** Matplotlib 的所有 `rcParams` 设置，导致字体被重置回了 Seaborn 默认的 `Arial` 字体。

  * **最终解决方案：**
    **不要**在 `sns.set_theme()` *之前* 设置 `rcParams`。正确的做法是，在调用 `sns.set_theme()` 时，**直接通过 `font` 参数告诉 Seaborn 使用哪个中文字体**。

      * **对应的代码单元格（步骤 1.1）**：

    <!-- end list -->

    ```python
    import numpy as np
    import matplotlib.pyplot as plt
    import seaborn as sns
    import os
    import glob 
    import matplotlib
    
    # --- [关键修正] ---
    # 确认 'SimHei' 字体在你的测试中可用
    font_name_to_use = 'SimHei' 
    
    # 1. 在调用 set_theme 时，直接指定 font 参数
    sns.set_theme(style="whitegrid", font=font_name_to_use)
    
    # 2. 解决更改字体后，负号 '-' 显示为方块的问题
    plt.rcParams['axes.unicode_minus'] = False 
    # --- [关键修正] 结束 ---
    
    print(f"库导入成功！中文显示已配置，Seaborn 正在使用: {font_name_to_use}")
    ```

-----

#### 问题 4：`KeyError: 'Number of cells'` (数据效率)

  * **问题现象：**
    在尝试解析 `log-n-cells.txt` 文件时，Jupyter 报错 `KeyError: 'Number of cells'`。

  * **问题诊断：**

    1.  该错误发生在 `df_efficiency.sort_values(by='Number of cells')`。
    2.  `KeyError` 意味着 `df_efficiency` 这个 DataFrame 是**空**的，或者**没有** `'Number of cells'` 这一列。
    3.  原因是用于解析日志的**正则表达式 (regex) 彻底错误**。我最初的代码是基于 `1data-efficiency.py` 脚本的 *预期* 输出（例如 `"8 cells"`）编写的。
    4.  而你提供的**实际日志**显示，关键信息是 `Splits:8`，并且 `Test R2:` 和 `Test error:` 之间的空格也与预期不符。

  * **最终解决方案：**
    根据你**实际粘贴**的日志内容，重写正则表达式，使其**精确匹配**日志格式。

      * **对应的代码单元格（步骤 3.1）**：

    <!-- end list -->

    ```python
    import re 
    import pandas as pd 
    
    log_file_path = '../results/variable-discharge/log-n-cells.txt'
    data_efficiency_results = []
    
    # [关键修正] 匹配 'Splits:8' 而不是 '8 cells'
    cell_regex = re.compile(r'Splits:(\d+)') 
    
    # [关键修正] 精确匹配你日志中的 "Test R2: 0.7... Test error: 9.7..."
    stats_regex = re.compile(r'Test R2: ([\d.-]+)\s+ Test error: ([\d.-]+)')
    
    current_cells = None
    
    try:
        with open(log_file_path, 'r', encoding='utf-8') as f:
            for line in f:
                cell_match = cell_regex.search(line)
                if cell_match:
                    current_cells = int(cell_match.group(1))
                
                stats_match = stats_regex.search(line)
                if stats_match and current_cells is not None:
                    data_efficiency_results.append({
                        'Number of cells': current_cells,
                        'Test R2': float(stats_match.group(1)),
                        'Test error (%)': float(stats_match.group(2))
                    })
                    current_cells = None
    
        df_efficiency = pd.DataFrame(data_efficiency_results)
        
        if df_efficiency.empty:
            print("!!! 错误：无法解析日志文件。")
        else:
            df_efficiency = df_efficiency.sort_values(by='Number of cells')
            print("成功解析 'log-n-cells.txt' 文件：")
            print(df_efficiency)
    
    except FileNotFoundError:
        print(f"!!! 错误：找不到日志文件 {log_file_path}")
    ```

-----

#### 问题 5：`R²` (R的平方) 显示为 `R2`

  * **问题现象：**
    在 Figure 5b 的图表中，Y 轴标签显示为 "R2"，而不是 "R²"。

  * **问题诊断：**
    你选择的 `SimHei` 字体虽然能显示中文字，但无法正确渲染 `²` (SUPERSCRIPT TWO, U+00B2) 这个特殊的 Unicode 字符，导致 Matplotlib 将其降级显示为普通的 `2`。

  * **最终解决方案：**
    使用 Matplotlib 内置的 **LaTeX 数学公式渲染**功能。通过在字符串中加入 `$...$`，我们可以强制 Matplotlib 将 `R^2` 渲染为 `R²`。

      * **对应的代码单元格（步骤 3.2）**：

    <!-- end list -->

    ```python
    # ... (Figure 5a 的代码不变) ...
    
    # --- 绘制 Figure 5b: R² vs 电芯数量 ---
    
    # [关键修正] 使用 LaTeX 字符串 R$^2$ 来显示 R²
    axes[1].plot(df_efficiency['Number of cells'], df_efficiency['Test R2'], 
                 marker='o', linestyle='--', color='blue')
    axes[1].set_xlabel('训练电芯数量 (Number of cells)', fontsize=14)
    axes[1].set_ylabel('R$^2$ 值 (R² Value)', fontsize=14) # <--- 修正点
    axes[1].set_title('复现 Figure 5b: 数据效率 (R²)', fontsize=16)
    
    # ... (后续代码不变) ...
    ```